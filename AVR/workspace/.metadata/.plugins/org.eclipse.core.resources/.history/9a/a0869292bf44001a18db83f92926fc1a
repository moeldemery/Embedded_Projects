/*
 * TMR0.c
 *
 *  Created on: 18 Jan 2020
 *      Author: Mohamed
 */

#include <../INC/TMR.h>

#define	TMR_Number_of_groups 3

//#define STORYMODE

TMR_config_t TMR_groups [2]=
{
	{	TIMER_0 , NORMAL_MODE , PRESCALER_1024	 ,DISABLE_TIMER_INT , 0 , 200 , DISABLE_OC_PIN ,DISABLE_PWM_PIN_MODE},
#ifdef STORYMODE
	{	TIMER_2 , FAST_PWM_MODE , PRESCALER_1024	 ,DISABLE_TIMER_INT , 0  , 0 , DISABLE_OC_PIN ,PWM_INV_MODE}
#else
	{	TIMER_2 , CTC_MODE , PRESCALER_64	 , COMPARE_INT_ENABLE, 0  , 125 , DISABLE_OC_PIN ,PWM_INV_MODE}
#endif
};



void TMR0_Init(void)
{
	u8 TCCR0_temp =TCCR0;
	switch (TMR_groups[0].Timer_mode) {
		case NORMAL_MODE:
		{
			CLR_BIT(TCCR0_temp,WGM00);
			CLR_BIT(TCCR0_temp,WGM01);
			break;

		}
		case PHASE_PWM_MODE:
		{
			SET_BIT(TCCR0_temp,WGM00);
			CLR_BIT(TCCR0_temp,WGM01);
			break;
		}
		case CTC_MODE:
		{
			CLR_BIT(TCCR0_temp,WGM00);
			SET_BIT(TCCR0_temp,WGM01);

			break;
		}
		case FAST_PWM_MODE:
		{
			SET_BIT(TCCR0_temp,WGM00);
			SET_BIT(TCCR0_temp,WGM01);
			break;
		}
		default:
			break;
	}

	if(TMR_groups[0].Timer_mode == NORMAL_MODE || TMR_groups[0].Timer_mode == CTC_MODE)
	{
		switch (TMR_groups[0].Timer_compare_pin)
		{
			case DISABLE_OC_PIN:
			{
				CLR_BIT(TCCR0_temp,COM00);
				CLR_BIT(TCCR0_temp,COM01);
				break;
			}
			case TOGGLE_OC_PIN:
			{
				SET_BIT(TCCR0_temp,COM00);
				CLR_BIT(TCCR0_temp,COM01);
				break;
			}
			case CLR_OC_PIN:
			{
				CLR_BIT(TCCR0_temp,COM00);
				SET_BIT(TCCR0_temp,COM01);
				break;
			}
			case SET_OC_PIN:
			{
				SET_BIT(TCCR0_temp,COM00);
				SET_BIT(TCCR0_temp,COM01);
				break;
			}
			default:
				break;
		}
	}
	else if(TMR_groups[0].Timer_mode == PHASE_PWM_MODE || TMR_groups[0].Timer_mode == FAST_PWM_MODE)
	{
		switch (TMR_groups[0].Timer_pwm_mode)
		{
			case DISABLE_PWM_PIN_MODE:
			{
				CLR_BIT(TCCR0_temp,COM00);
				CLR_BIT(TCCR0_temp,COM01);
				break;
			}
			case PWM_NON_INV_MODE:
			{
				CLR_BIT(TCCR0_temp,COM00);
				SET_BIT(TCCR0_temp,COM01);
				break;
			}
			case PWM_INV_MODE:
			{
				SET_BIT(TCCR0_temp,COM00);
				SET_BIT(TCCR0_temp,COM01);
				break;
			}
			default:
				break;
		}
	}

	switch (TMR_groups[0].Timer_prescaller)
	{
		case DISABLE_PRESCALER:
		{
			CLR_BIT(TCCR0_temp,CS00);
			CLR_BIT(TCCR0_temp,CS01);
			CLR_BIT(TCCR0_temp,CS02);
			break;
		}
		case PRESCALER_1:
		{
			SET_BIT(TCCR0_temp,CS00);
			CLR_BIT(TCCR0_temp,CS01);
			CLR_BIT(TCCR0_temp,CS02);
			break;
		}
		case PRESCALER_8:
		{
			CLR_BIT(TCCR0_temp,CS00);
			SET_BIT(TCCR0_temp,CS01);
			CLR_BIT(TCCR0_temp,CS02);
			break;
		}
		case PRESCALER_64:
		{
			SET_BIT(TCCR0_temp,CS00);
			SET_BIT(TCCR0_temp,CS01);
			CLR_BIT(TCCR0_temp,CS02);
			break;
		}
		case PRESCALER_256:
		{
			CLR_BIT(TCCR0_temp,CS00);
			CLR_BIT(TCCR0_temp,CS01);
			SET_BIT(TCCR0_temp,CS02);
			break;
		}
		case PRESCALER_1024:
		{
			SET_BIT(TCCR0_temp,CS00);
			CLR_BIT(TCCR0_temp,CS01);
			SET_BIT(TCCR0_temp,CS02);
			break;
		}
		default:
			break;
	}

	TCNT0 = TMR_groups[0].Timer_startingValue;
	OCR0 = TMR_groups[0].Timer_compareValue;
	TCCR0=TCCR0_temp;

}

void TMR0_Disable(void)
{
	u8 TCCR0_temp =TCCR0;
	CLR_BIT(TCCR0_temp,CS00);
	CLR_BIT(TCCR0_temp,CS01);
	CLR_BIT(TCCR0_temp,CS02);
	CLR_BIT(TCCR0_temp,COM00);
	CLR_BIT(TCCR0_temp,COM01);
	TCCR0=TCCR0_temp;				// we use temp to keep the struct with old selection in struct without changing it
}

void TMR0_PWM(u8 Duty_cycle)
{
	TMR0_Disable();
	TMR_groups[0].Timer_compareValue=Duty_cycle;
	TMR0_Init();
}
/**************************************************************/
/**************************************************************/
/**************************************************************/


void TMR2_Init(void)
{
	u8 TCCR2_temp =TCCR2;
	switch (TMR_groups[1].Timer_mode) {
		case NORMAL_MODE:
		{
			CLR_BIT(TCCR2_temp,WGM20);
			CLR_BIT(TCCR2_temp,WGM21);
			break;
		}
		case PHASE_PWM_MODE:
		{
			SET_BIT(TCCR2_temp,WGM20);
			CLR_BIT(TCCR2_temp,WGM21);
			break;
		}
		case CTC_MODE:
		{
			CLR_BIT(TCCR2_temp,WGM20);
			SET_BIT(TCCR2_temp,WGM21);

			break;
		}
		case FAST_PWM_MODE:
		{
			SET_BIT(TCCR2_temp,WGM20);
			SET_BIT(TCCR2_temp,WGM21);
			break;
		}
		default:
			break;
	}

	if(TMR_groups[1].Timer_mode == NORMAL_MODE || TMR_groups[1].Timer_mode == CTC_MODE)
	{
		switch (TMR_groups[1].Timer_compare_pin)
		{
			case DISABLE_OC_PIN:
			{
				CLR_BIT(TCCR2_temp,COM20);
				CLR_BIT(TCCR2_temp,COM21);
				break;
			}
			case TOGGLE_OC_PIN:
			{
				SET_BIT(TCCR2_temp,COM20);
				CLR_BIT(TCCR2_temp,COM21);
				break;
			}
			case CLR_OC_PIN:
			{
				CLR_BIT(TCCR2_temp,COM20);
				SET_BIT(TCCR2_temp,COM21);
				break;
			}
			case SET_OC_PIN:
			{
				SET_BIT(TCCR2_temp,COM20);
				SET_BIT(TCCR2_temp,COM21);
				break;
			}
			default:
				break;
		}
	}
	else if(TMR_groups[1].Timer_mode == PHASE_PWM_MODE || TMR_groups[1].Timer_mode == FAST_PWM_MODE)
	{
		switch (TMR_groups[1].Timer_pwm_mode)
		{
			case DISABLE_PWM_PIN_MODE:
			{
				CLR_BIT(TCCR2_temp,COM20);
				CLR_BIT(TCCR2_temp,COM21);
				break;
			}
			case PWM_NON_INV_MODE:
			{
				CLR_BIT(TCCR2_temp,COM20);
				SET_BIT(TCCR2_temp,COM21);
				break;
			}
			case PWM_INV_MODE:
			{
				SET_BIT(TCCR2_temp,COM20);
				SET_BIT(TCCR2_temp,COM21);
				break;
			}
			default:
				break;
		}
	}

	switch (TMR_groups[1].Timer_prescaller)
	{
		case DISABLE_PRESCALER:
		{
			CLR_BIT(TCCR2_temp,CS20);
			CLR_BIT(TCCR2_temp,CS21);
			CLR_BIT(TCCR2_temp,CS22);
			break;
		}
		case PRESCALER_1:
		{
			SET_BIT(TCCR2_temp,CS20);
			CLR_BIT(TCCR2_temp,CS21);
			CLR_BIT(TCCR2_temp,CS22);
			break;
		}
		case PRESCALER_8:
		{
			CLR_BIT(TCCR2_temp,CS20);
			SET_BIT(TCCR2_temp,CS21);
			CLR_BIT(TCCR2_temp,CS22);
			break;
		}
		case PRESCALER_64:
		{
			SET_BIT(TCCR2_temp,CS20);
			SET_BIT(TCCR2_temp,CS21);
			CLR_BIT(TCCR2_temp,CS22);
			break;
		}
		case PRESCALER_256:
		{
			CLR_BIT(TCCR2_temp,CS20);
			CLR_BIT(TCCR2_temp,CS21);
			SET_BIT(TCCR2_temp,CS22);
			break;
		}
		case PRESCALER_1024:
		{
			SET_BIT(TCCR2_temp,CS20);
			CLR_BIT(TCCR2_temp,CS21);
			SET_BIT(TCCR2_temp,CS22);
			break;
		}
		default:
			break;
	}


		switch (TMR_groups[0].Timer_intrrupt)
		{
			case DISABLE_TIMER_INT:
			{
				CLR_BIT(TCCR0_temp,COM00);
				CLR_BIT(TCCR0_temp,COM01);
				break;
			}
			case COMPARE_INT_ENABLE:
			{
				SET_BIT(TCCR0_temp,COM00);
				CLR_BIT(TCCR0_temp,COM01);
				break;
			}
			case OVERFLOW_INT_ENABLE:
			{
				CLR_BIT(TCCR0_temp,COM00);
				SET_BIT(TCCR0_temp,COM01);
				break;
			}
			case OVERFLOW_COMPARE_INT_ENABLE:
			{
				SET_BIT(TCCR0_temp,COM00);
				SET_BIT(TCCR0_temp,COM01);
				break;
			}
			default:
				break;
		}

	TCNT2 = TMR_groups[1].Timer_startingValue;
	OCR2 = TMR_groups[1].Timer_compareValue;
	TCCR2=TCCR2_temp;

}

void TMR2_Disable(void)
{
	u8 TCCR2_temp =TCCR2;
	CLR_BIT(TCCR2_temp,CS20);
	CLR_BIT(TCCR2_temp,CS21);
	CLR_BIT(TCCR2_temp,CS22);
	CLR_BIT(TCCR2_temp,COM20);
	CLR_BIT(TCCR2_temp,COM21);
	TCCR2=TCCR2_temp;				// we use temp to keep the struct with old selection in struct without changing it
}

void TMR2_PWM(u8 Duty_cycle)
{
	TMR2_Disable();
	TMR_groups[1].Timer_compareValue=Duty_cycle;
	TMR2_Init();
}
