/*
 * UART_driver.c
 *
 *  Created on: 15 Jan 2020
 *      Author: Mohamed
 */
#include "UART_driver.h"


UASRT_config_t UART_group[] = {{RX_TX_EN 	 , UART_MODE ,	 DATA_8_BIT 	, DISABLE_PARITY, \
								ENDING_1_BIT , RISING_TX_FALLING_RX 		,9600 , DISABLE_INT}};

void UART_void_Init(void)
{
	u32 ubrr=(u32) (F_CPU/16.0/(float)(UART_group[0].BoadRate -1));
	UBRRH= (u8) (ubrr>>8);

	UBRRL= (u8) ubrr;
	u8	UCSRB_temp=0;
	u8  UCSRC_temp=0;
	/****************************************************/
	switch (UART_group[0].enable)
	{
		case RX_EN:
		{
			SET_BIT(UCSRB_temp,RXEN);
			break;
		}
		case TX_EN:
		{
			SET_BIT(UCSRB_temp,TXEN);
			break;
		}
		case RX_TX_EN:
		{
			SET_BIT(UCSRB_temp,RXEN);
			SET_BIT(UCSRB_temp,TXEN);
			break;
		}
		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	}
	/************************************************************************************************/
	switch (UART_group[0].UART_USART)
	{
		case UART_MODE:
		{

			CLR_BIT(UCSRC_temp,UMSEL);
			break;
		}
		case USART_MODE:
		{
			SET_BIT(UCSRC_temp,UMSEL);
			break;
		}
		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	}
	/************************************************************************************************/
	switch (UART_group[0].dataFrame)
	{
		case DATA_5_BIT:										//z2-z1-z0 = 000
		{
			CLR_BIT(UCSRC_temp,UCSZ0);
			CLR_BIT(UCSRC_temp,UCSZ1);
			CLR_BIT(UCSRB_temp,UCSZ2);
			break;
		}
		case DATA_6_BIT:										//z2-z1-z0 = 001
		{
			UCSRC_temp |=  ((1<<UCSZ0));
			UCSRC_temp &= ~((1<<UCSZ1));
			CLR_BIT(UCSRB_temp,UCSZ2);
			break;
		}
		case DATA_7_BIT:										//z2-z1-z0 = 010
		{
			UCSRC_temp &= ~((1<<UCSZ0));
			UCSRC_temp |=  ((1<<UCSZ1));
			CLR_BIT(UCSRB_temp,UCSZ2);
			break;
		}
		case DATA_8_BIT:										//z2-z1-z0 = 011
		{
			UCSRC_temp |=  ((1<<UCSZ0)|(1<<UCSZ1));
			CLR_BIT(UCSRB_temp,UCSZ2);
			break;
		}
		case DATA_9_BIT:										//z2-z1-z0 = 111
		{
			UCSRC_temp |=  ((1<<UCSZ0)|(1<<UCSZ1));
			SET_BIT(UCSRB_temp,UCSZ2);
			break;
		}
		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	}
	/************************************************************************************************/
	switch (UART_group[0].parity)
	{
		case DISABLE_PARITY:						//UPM1-UPM0 = 00
		{
			UCSRC_temp &= ~((1<<UPM1)|(1<<UPM0));		//Can't use set bit because UCSRC overlap UDDRH
			break;
		}
		case EVEN_PARITY:							//UPM1-UPM0 = 10
		{
			UCSRC_temp |=  ((1<<UPM1));		//Can't use set bit because UCSRC overlap UDDRH
			UCSRC_temp &= ~((1<<UPM0));
			break;
		}
		case ODD_PARITY:							//UPM1-UPM0 = 11
		{
			UCSRC_temp |= ((1<<UPM1)|(1<<UPM0));		//Can't use set bit because UCSRC overlap UDDRH
			break;
		}
		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	}
	/************************************************************************************************/
	switch (UART_group[0].endingBits)
	{
		case ENDING_1_BIT:							//USBS = 0
		{
			UCSRC_temp &= ~((1<<USBS));		//Can't use set bit because UCSRC overlap UDDRH
			break;
		}
		case ENDING_2_BIT:							//USBS = 1
		{
			UCSRC_temp |=  ((1<<USBS));		//Can't use set bit because UCSRC overlap UDDRH

			break;
		}

		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	}
	/************************************************************************************************/
	/*switch (UART_group[0].clockPolarity)
	{
		case RISING_TX_FALLING_RX:							//UCPOL = 0
		{
			UCSRC_temp &= ~((1<<UCPOL));		//Can't use set bit because UCSRC overlap UDDRH
			break;
		}
		case FALLING_TX_RISING_RX:							//UCPOL = 1
		{
			UCSRC_temp |=  ((1<<UCPOL));		//Can't use set bit because UCSRC overlap UDDRH

			break;
		}

		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	}*/
	UBRRH=0;
	SET_BIT(UCSRC_temp,URSEL);
	UCSRB=UCSRB_temp;
	UCSRC=UCSRC_temp;

}


void UART_void_TXBlocking(u16 u16_data)
{
	while( !GET_BIT(UCSRA,UDRE));
	switch (UART_group[0].dataFrame) {
		case DATA_5_BIT:
		case DATA_6_BIT:
		case DATA_7_BIT:
		case DATA_8_BIT:
		{
			UDR= (u8)u16_data;
			break;
		}
		case DATA_9_BIT:
		{
			CLR_BIT(UCSRB,TXB8);
			if(u16_data & 0x0100 )
			{
				SET_BIT(UCSRB,TXB8);
			}
			break;
		}
		default:
		{
			break;
		}
	}

}


u16 UART_U16_RXBlocking(void)
{
	u16 copy_u16_dataRx;
	while( !GET_BIT(UCSRA,RXC));

	switch (UART_group[0].dataFrame)
	{
			case DATA_5_BIT:
			case DATA_6_BIT:
			case DATA_7_BIT:
			case DATA_8_BIT:
			{
				copy_u16_dataRx=UDR;
				break;
			}
			case DATA_9_BIT:
			{
				u8 copy_u8_dataHigh = (UCSRA>>1) & 0x01 ;
				u8 copy_u8_dataLow = UDR;

				if ( UCSRA & ((1<<FE)|(1<<DOR)|(1<<PE)) )
				{
					return -1;
				}

				copy_u16_dataRx=(copy_u8_dataHigh<<8)|copy_u8_dataLow;
				break;
			}
			default:
			{
				break;
			}
	}
	return copy_u16_dataRx;
}
