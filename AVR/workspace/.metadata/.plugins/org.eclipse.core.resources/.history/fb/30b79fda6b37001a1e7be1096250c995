/*
 * UART_driver.c
 *
 *  Created on: 15 Jan 2020
 *      Author: Mohamed
 */
#include "UART_driver.h"


UASRT_config_t UART_group[] = {{RX_TX_EN 	 , UART_MODE ,	 DATA_8_BIT 	, DISABLE_PARITY, \
								ENDING_1_BIT , RISING_TX_FALLING_RX 		,9600}};

void UART_Init(void)
{
	u32 ubrr= F_CPU/16/(UART_group[0].BoadRate -1);
	UBRRH= (u8) ubrr>>8;
	UBRRL= (u8) ubrr;
	/****************************************************/
	switch (UART_group[0].enable)
	{
		case RX_EN:
		{
			SET_BIT(UCSRB,RXEN);
			break;
		}
		case TX_EN:
		{
			SET_BIT(UCSRB,TXEN);
			break;
		}
		case RX_TX_EN:
		{
			SET_BIT(UCSRB,RXEN);
			SET_BIT(UCSRB,TXEN);
			break;
		}
		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	/************************************************************************************************/
	switch (UART_group[0].UART_USART)
	{
		case UART_MODE:
		{
			UCSRC &= ~((1<<URSEL)|(1<<UMSEL));		//Can't use set bit because UCSRC overlap UDDRH
			break;
		}
		case USART_MODE:
		{
			UCSRC |= ((1<<URSEL)|(1<<UMSEL));		//Can't use set bit because UCSRC overlap UDDRH
			break;
		}
		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	}
	/************************************************************************************************/
	switch (UART_group[0].dataFrame)
	{
		case DATA_5_BIT:										//z2-z1-z0 = 000
		{
			UCSRC &= ~((1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1));		//Can't use set bit because UCSRC overlap UDDRH
			CLR_BIT(UCSRB,UCSZ2);
			break;
		}
		case DATA_6_BIT:										//z2-z1-z0 = 001
		{
			UCSRC |=  ((1<<URSEL)|(1<<UCSZ0));
			UCSRC &= ~((1<<URSEL)|(1<<UCSZ1));
			CLR_BIT(UCSRB,UCSZ2);
			break;
		}
		case DATA_7_BIT:										//z2-z1-z0 = 010
		{
			UCSRC &= ~((1<<URSEL)|(1<<UCSZ0));
			UCSRC |=  ((1<<URSEL)|(1<<UCSZ1));
			CLR_BIT(UCSRB,UCSZ2);
			break;
		}
		case DATA_8_BIT:										//z2-z1-z0 = 011
		{
			UCSRC |=  ((1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1));
			CLR_BIT(UCSRB,UCSZ2);
			break;
		}
		case DATA_9_BIT:										//z2-z1-z0 = 111
		{
			UCSRC |=  ((1<<URSEL)|(1<<UCSZ0)|(1<<UCSZ1));
			UCSRC &= ~((1<<URSEL)|(1<<UCSZ1));
			SET_BIT(UCSRB,UCSZ2);
			break;
		}
		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	}
	/************************************************************************************************/
	switch (UART_group[0].parity)
	{
		case DISABLE_PARITY:						//UPM1-UPM0 = 00
		{
			UCSRC &= ~((1<<URSEL)|(1<<UPM1)|(1<<UPM0));		//Can't use set bit because UCSRC overlap UDDRH
			break;
		}
		case EVEN_PARITY:							//UPM1-UPM0 = 10
		{
			UCSRC |=  ((1<<URSEL)|(1<<UPM1));		//Can't use set bit because UCSRC overlap UDDRH
			UCSRC &= ~((1<<URSEL)|(1<<UPM0));
			break;
		}
		case ODD_PARITY:							//UPM1-UPM0 = 11
		{
			UCSRC |= ((1<<URSEL)|(1<<UPM1)|(1<<UPM0));		//Can't use set bit because UCSRC overlap UDDRH
			break;
		}
		default:
		{
			//#warning "unexpected input in UART Enable type"
			break;
		}
	}

}
